/*
 * This file is generated by jOOQ.
 */
package kr.co.commerce.common.jooq.generated.tables.daos


import java.time.LocalDateTime

import kotlin.collections.List

import kr.co.commerce.common.jooq.generated.tables.JMember
import kr.co.commerce.common.jooq.generated.tables.pojos.Member
import kr.co.commerce.common.jooq.generated.tables.records.MemberRecord

import org.jooq.Configuration
import org.jooq.impl.DAOImpl


/**
 * 고객 테이블
 */
@Suppress("UNCHECKED_CAST")
open class MemberDao(configuration: Configuration?) : DAOImpl<MemberRecord, Member, Long>(JMember.MEMBER, Member::class.java, configuration) {

    /**
     * Create a new MemberDao without any configuration
     */
    constructor(): this(null)

    override fun getId(o: Member): Long? = o.seq

    /**
     * Fetch records that have <code>seq BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJSeq(lowerInclusive: Long?, upperInclusive: Long?): List<Member> = fetchRange(JMember.MEMBER.SEQ, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>seq IN (values)</code>
     */
    fun fetchByJSeq(vararg values: Long): List<Member> = fetch(JMember.MEMBER.SEQ, *values.toTypedArray())

    /**
     * Fetch a unique record that has <code>seq = value</code>
     */
    fun fetchOneByJSeq(value: Long): Member? = fetchOne(JMember.MEMBER.SEQ, value)

    /**
     * Fetch records that have <code>name BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJName(lowerInclusive: String, upperInclusive: String): List<Member> = fetchRange(JMember.MEMBER.NAME, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>name IN (values)</code>
     */
    fun fetchByJName(vararg values: String): List<Member> = fetch(JMember.MEMBER.NAME, *values)

    /**
     * Fetch records that have <code>email BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJEmail(lowerInclusive: String, upperInclusive: String): List<Member> = fetchRange(JMember.MEMBER.EMAIL, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>email IN (values)</code>
     */
    fun fetchByJEmail(vararg values: String): List<Member> = fetch(JMember.MEMBER.EMAIL, *values)

    /**
     * Fetch a unique record that has <code>email = value</code>
     */
    fun fetchOneByJEmail(value: String): Member? = fetchOne(JMember.MEMBER.EMAIL, value)

    /**
     * Fetch records that have <code>password BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJPassword(lowerInclusive: String, upperInclusive: String): List<Member> = fetchRange(JMember.MEMBER.PASSWORD, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>password IN (values)</code>
     */
    fun fetchByJPassword(vararg values: String): List<Member> = fetch(JMember.MEMBER.PASSWORD, *values)

    /**
     * Fetch records that have <code>grade_code BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJGradeCode(lowerInclusive: String, upperInclusive: String): List<Member> = fetchRange(JMember.MEMBER.GRADE_CODE, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>grade_code IN (values)</code>
     */
    fun fetchByJGradeCode(vararg values: String): List<Member> = fetch(JMember.MEMBER.GRADE_CODE, *values)

    /**
     * Fetch records that have <code>created_by BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJCreatedBy(lowerInclusive: String, upperInclusive: String): List<Member> = fetchRange(JMember.MEMBER.CREATED_BY, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>created_by IN (values)</code>
     */
    fun fetchByJCreatedBy(vararg values: String): List<Member> = fetch(JMember.MEMBER.CREATED_BY, *values)

    /**
     * Fetch records that have <code>created_time BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJCreatedTime(lowerInclusive: LocalDateTime?, upperInclusive: LocalDateTime?): List<Member> = fetchRange(JMember.MEMBER.CREATED_TIME, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>created_time IN (values)</code>
     */
    fun fetchByJCreatedTime(vararg values: LocalDateTime): List<Member> = fetch(JMember.MEMBER.CREATED_TIME, *values)

    /**
     * Fetch records that have <code>updated_by BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJUpdatedBy(lowerInclusive: String, upperInclusive: String): List<Member> = fetchRange(JMember.MEMBER.UPDATED_BY, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>updated_by IN (values)</code>
     */
    fun fetchByJUpdatedBy(vararg values: String): List<Member> = fetch(JMember.MEMBER.UPDATED_BY, *values)

    /**
     * Fetch records that have <code>updated_time BETWEEN lowerInclusive AND
     * upperInclusive</code>
     */
    fun fetchRangeOfJUpdatedTime(lowerInclusive: LocalDateTime?, upperInclusive: LocalDateTime?): List<Member> = fetchRange(JMember.MEMBER.UPDATED_TIME, lowerInclusive, upperInclusive)

    /**
     * Fetch records that have <code>updated_time IN (values)</code>
     */
    fun fetchByJUpdatedTime(vararg values: LocalDateTime): List<Member> = fetch(JMember.MEMBER.UPDATED_TIME, *values)
}
